{"ast":null,"code":"import { Color } from '@pixi/color';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { Rectangle } from '@pixi/math';\nconst tempRect = new Rectangle();\nconst tempRect2 = new Rectangle();\nclass RenderTextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.defaultMaskStack = [];\n    this.current = null;\n    this.sourceFrame = new Rectangle();\n    this.destinationFrame = new Rectangle();\n    this.viewportFrame = new Rectangle();\n  }\n  bind() {\n    let renderTexture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let sourceFrame = arguments.length > 1 ? arguments[1] : undefined;\n    let destinationFrame = arguments.length > 2 ? arguments[2] : undefined;\n    const renderer = this.renderer;\n    this.current = renderTexture;\n    let baseTexture;\n    let framebuffer;\n    let resolution;\n    if (renderTexture) {\n      baseTexture = renderTexture.baseTexture;\n      resolution = baseTexture.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderTexture.frame.width;\n        tempRect.height = renderTexture.frame.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        tempRect2.x = renderTexture.frame.x;\n        tempRect2.y = renderTexture.frame.y;\n        tempRect2.width = sourceFrame.width;\n        tempRect2.height = sourceFrame.height;\n        destinationFrame = tempRect2;\n      }\n      framebuffer = baseTexture.framebuffer;\n    } else {\n      resolution = renderer.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderer._view.screen.width;\n        tempRect.height = renderer._view.screen.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        destinationFrame = tempRect;\n        destinationFrame.width = sourceFrame.width;\n        destinationFrame.height = sourceFrame.height;\n      }\n    }\n    const viewportFrame = this.viewportFrame;\n    viewportFrame.x = destinationFrame.x * resolution;\n    viewportFrame.y = destinationFrame.y * resolution;\n    viewportFrame.width = destinationFrame.width * resolution;\n    viewportFrame.height = destinationFrame.height * resolution;\n    if (!renderTexture) {\n      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n    }\n    viewportFrame.ceil();\n    this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n    if (renderTexture) {\n      this.renderer.mask.setMaskStack(baseTexture.maskStack);\n    } else {\n      this.renderer.mask.setMaskStack(this.defaultMaskStack);\n    }\n    this.sourceFrame.copyFrom(sourceFrame);\n    this.destinationFrame.copyFrom(destinationFrame);\n  }\n  clear(clearColor, mask) {\n    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;\n    const color = clearColor ? Color.shared.setValue(clearColor) : fallbackColor;\n    const destinationFrame = this.destinationFrame;\n    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;\n    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n    if (clearMask) {\n      let {\n        x,\n        y,\n        width,\n        height\n      } = this.viewportFrame;\n      x = Math.round(x);\n      y = Math.round(y);\n      width = Math.round(width);\n      height = Math.round(height);\n      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n      this.renderer.gl.scissor(x, y, width, height);\n    }\n    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);\n    if (clearMask) {\n      this.renderer.scissor.pop();\n    }\n  }\n  resize() {\n    this.bind(null);\n  }\n  reset() {\n    this.bind(null);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nRenderTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"renderTexture\"\n};\nextensions.add(RenderTextureSystem);\nexport { RenderTextureSystem };","map":{"version":3,"names":["tempRect","Rectangle","tempRect2","RenderTextureSystem","constructor","renderer","defaultMaskStack","current","sourceFrame","destinationFrame","viewportFrame","bind","renderTexture","arguments","length","undefined","baseTexture","framebuffer","resolution","width","frame","height","x","y","_view","screen","view","ceil","projection","update","mask","setMaskStack","maskStack","copyFrom","clear","clearColor","fallbackColor","background","backgroundColor","color","Color","shared","setValue","baseFrame","clearMask","Math","round","gl","enable","SCISSOR_TEST","scissor","red","green","blue","alpha","pop","resize","reset","destroy","extension","type","ExtensionType","RendererSystem","name","extensions","add"],"sources":["/Users/brunoateruel/Personal/Website/bat223.github.io/my-website/node_modules/@pixi/core/src/renderTexture/RenderTextureSystem.ts"],"sourcesContent":["import { Color } from '@pixi/color';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { Rectangle } from '@pixi/math';\n\nimport type { ColorSource } from '@pixi/color';\nimport type { BUFFER_BITS } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { ISize } from '@pixi/math';\nimport type { MaskData } from '../mask/MaskData';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { BaseRenderTexture } from './BaseRenderTexture';\nimport type { RenderTexture } from './RenderTexture';\n\n// Temporary rectangle for assigned sourceFrame or destinationFrame\nconst tempRect = new Rectangle();\n\n// Temporary rectangle for renderTexture destinationFrame\nconst tempRect2 = new Rectangle();\n\n/* eslint-disable max-len */\n/**\n * System plugin to the renderer to manage render textures.\n *\n * Should be added after FramebufferSystem\n *\n * ### Frames\n *\n * The `RenderTextureSystem` holds a sourceFrame â†’ destinationFrame projection. The following table explains the different\n * coordinate spaces used:\n *\n * | Frame                  | Description                                                      | Coordinate System                                       |\n * | ---------------------- | ---------------------------------------------------------------- | ------------------------------------------------------- |\n * | sourceFrame            | The rectangle inside of which display-objects are being rendered | **World Space**: The origin on the top-left             |\n * | destinationFrame       | The rectangle in the render-target (canvas or texture) into which contents should be rendered | If rendering to the canvas, this is in screen space and the origin is on the top-left. If rendering to a render-texture, this is in its base-texture's space with the origin on the bottom-left.  |\n * | viewportFrame          | The framebuffer viewport corresponding to the destination-frame  | **Window Coordinates**: The origin is always on the bottom-left. |\n * @memberof PIXI\n */\nexport class RenderTextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'renderTexture',\n    };\n\n    /* eslint-enable max-len */\n\n    /**\n     * List of masks for the {@link PIXI.StencilSystem}.\n     * @readonly\n     */\n    public defaultMaskStack: Array<MaskData>;\n\n    /**\n     * Render texture currently bound. {@code null} if rendering to the canvas.\n     * @readonly\n     */\n    public current: RenderTexture | null;\n\n    /**\n     * The source frame for the render-target's projection mapping.\n     *\n     * See {@link PIXI.ProjectionSystem#sourceFrame} for more details\n     */\n    public readonly sourceFrame: Rectangle;\n\n    /**\n     * The destination frame for the render-target's projection mapping.\n     *\n     * See {@link PIXI.ProjectionSystem#destinationFrame} for more details.\n     */\n    public readonly destinationFrame: Rectangle;\n\n    /**\n     * The viewport frame for the render-target's viewport binding. This is equal to the destination-frame\n     * for render-textures, while it is y-flipped when rendering to the screen (i.e. its origin is always on\n     * the bottom-left).\n     */\n    public readonly viewportFrame: Rectangle;\n\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.defaultMaskStack = [];\n        this.current = null;\n        this.sourceFrame = new Rectangle();\n        this.destinationFrame = new Rectangle();\n        this.viewportFrame = new Rectangle();\n    }\n\n    /**\n     * Bind the current render texture.\n     * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.\n     * @param sourceFrame - Part of world that is mapped to the renderTexture.\n     * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.\n     */\n    bind(renderTexture: RenderTexture = null, sourceFrame?: Rectangle, destinationFrame?: Rectangle): void\n    {\n        const renderer = this.renderer;\n\n        this.current = renderTexture;\n\n        let baseTexture: BaseRenderTexture;\n        let framebuffer;\n        let resolution;\n\n        if (renderTexture)\n        {\n            baseTexture = renderTexture.baseTexture as BaseRenderTexture;\n\n            resolution = baseTexture.resolution;\n\n            if (!sourceFrame)\n            {\n                tempRect.width = renderTexture.frame.width;\n                tempRect.height = renderTexture.frame.height;\n\n                sourceFrame = tempRect;\n            }\n\n            if (!destinationFrame)\n            {\n                tempRect2.x = renderTexture.frame.x;\n                tempRect2.y = renderTexture.frame.y;\n                tempRect2.width = sourceFrame.width;\n                tempRect2.height = sourceFrame.height;\n\n                destinationFrame = tempRect2;\n            }\n\n            framebuffer = baseTexture.framebuffer;\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!sourceFrame)\n            {\n                tempRect.width = renderer._view.screen.width;\n                tempRect.height = renderer._view.screen.height;\n\n                sourceFrame = tempRect;\n            }\n\n            if (!destinationFrame)\n            {\n                destinationFrame = tempRect;\n\n                destinationFrame.width = sourceFrame.width;\n                destinationFrame.height = sourceFrame.height;\n            }\n        }\n\n        const viewportFrame = this.viewportFrame;\n\n        viewportFrame.x = destinationFrame.x * resolution;\n        viewportFrame.y = destinationFrame.y * resolution;\n        viewportFrame.width = destinationFrame.width * resolution;\n        viewportFrame.height = destinationFrame.height * resolution;\n\n        if (!renderTexture)\n        {\n            viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n        }\n\n        viewportFrame.ceil();\n\n        this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n\n        if (renderTexture)\n        {\n            this.renderer.mask.setMaskStack(baseTexture.maskStack);\n        }\n        else\n        {\n            this.renderer.mask.setMaskStack(this.defaultMaskStack);\n        }\n\n        this.sourceFrame.copyFrom(sourceFrame);\n        this.destinationFrame.copyFrom(destinationFrame);\n    }\n\n    /**\n     * Erases the render texture and fills the drawing area with a colour.\n     * @param clearColor - The color as rgba, default to use the renderer backgroundColor\n     * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks\n     *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.\n     */\n    clear(clearColor?: ColorSource, mask?: BUFFER_BITS): void\n    {\n        const fallbackColor = this.current\n            ? (this.current.baseTexture as BaseRenderTexture).clear\n            : this.renderer.background.backgroundColor;\n        const color = clearColor ? Color.shared.setValue(clearColor) : fallbackColor;\n\n        const destinationFrame = this.destinationFrame;\n        const baseFrame: ISize = this.current ? this.current.baseTexture : this.renderer._view.screen;\n        const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n\n        if (clearMask)\n        {\n            let { x, y, width, height } = this.viewportFrame;\n\n            x = Math.round(x);\n            y = Math.round(y);\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // TODO: ScissorSystem should cache whether the scissor test is enabled or not.\n            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n            this.renderer.gl.scissor(x, y, width, height);\n        }\n\n        this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);\n\n        if (clearMask)\n        {\n            // Restore the scissor box\n            this.renderer.scissor.pop();\n        }\n    }\n\n    resize(): void // screenWidth, screenHeight)\n    {\n        // resize the root only!\n        this.bind(null);\n    }\n\n    /** Resets render-texture state. */\n    reset(): void\n    {\n        this.bind(null);\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(RenderTextureSystem);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}