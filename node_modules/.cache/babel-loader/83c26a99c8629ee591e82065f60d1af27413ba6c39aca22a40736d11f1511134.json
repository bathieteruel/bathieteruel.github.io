{"ast":null,"code":"import { MASK_TYPES } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { SpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter.mjs';\nimport { MaskData } from './MaskData.mjs';\nclass MaskSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.enableScissor = true;\n    this.alphaMaskPool = [];\n    this.maskDataPool = [];\n    this.maskStack = [];\n    this.alphaMaskIndex = 0;\n  }\n  setMaskStack(maskStack) {\n    this.maskStack = maskStack;\n    this.renderer.scissor.setMaskStack(maskStack);\n    this.renderer.stencil.setMaskStack(maskStack);\n  }\n  push(target, maskDataOrTarget) {\n    let maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      const d = this.maskDataPool.pop() || new MaskData();\n      d.pooled = true;\n      d.maskObject = maskDataOrTarget;\n      maskData = d;\n    }\n    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    maskData.copyCountersOrReset(maskAbove);\n    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;\n    if (maskData.autoDetect) {\n      this.detect(maskData);\n    }\n    maskData._target = target;\n    if (maskData.type !== MASK_TYPES.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case MASK_TYPES.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case MASK_TYPES.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case MASK_TYPES.SPRITE:\n          maskData.copyCountersOrReset(null);\n          this.pushSpriteMask(maskData);\n          break;\n        case MASK_TYPES.COLOR:\n          this.pushColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    if (maskData.type === MASK_TYPES.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n  }\n  pop(target) {\n    const maskData = this.maskStack.pop();\n    if (!maskData || maskData._target !== target) {\n      return;\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case MASK_TYPES.SCISSOR:\n          this.renderer.scissor.pop(maskData);\n          break;\n        case MASK_TYPES.STENCIL:\n          this.renderer.stencil.pop(maskData.maskObject);\n          break;\n        case MASK_TYPES.SPRITE:\n          this.popSpriteMask(maskData);\n          break;\n        case MASK_TYPES.COLOR:\n          this.popColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    maskData.reset();\n    if (maskData.pooled) {\n      this.maskDataPool.push(maskData);\n    }\n    if (this.maskStack.length !== 0) {\n      const maskCurrent = this.maskStack[this.maskStack.length - 1];\n      if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {\n        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n      }\n    }\n  }\n  detect(maskData) {\n    const maskObject = maskData.maskObject;\n    if (!maskObject) {\n      maskData.type = MASK_TYPES.COLOR;\n    } else if (maskObject.isSprite) {\n      maskData.type = MASK_TYPES.SPRITE;\n    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {\n      maskData.type = MASK_TYPES.SCISSOR;\n    } else {\n      maskData.type = MASK_TYPES.STENCIL;\n    }\n  }\n  pushSpriteMask(maskData) {\n    const {\n      maskObject\n    } = maskData;\n    const target = maskData._target;\n    let alphaMaskFilter = maskData._filters;\n    if (!alphaMaskFilter) {\n      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n      if (!alphaMaskFilter) {\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n      }\n    }\n    const renderer = this.renderer;\n    const renderTextureSystem = renderer.renderTexture;\n    let resolution;\n    let multisample;\n    if (renderTextureSystem.current) {\n      const renderTexture = renderTextureSystem.current;\n      resolution = maskData.resolution || renderTexture.resolution;\n      multisample = maskData.multisample ?? renderTexture.multisample;\n    } else {\n      resolution = maskData.resolution || renderer.resolution;\n      multisample = maskData.multisample ?? renderer.multisample;\n    }\n    alphaMaskFilter[0].resolution = resolution;\n    alphaMaskFilter[0].multisample = multisample;\n    alphaMaskFilter[0].maskSprite = maskObject;\n    const stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(true);\n    renderer.filter.push(target, alphaMaskFilter);\n    target.filterArea = stashFilterArea;\n    if (!maskData._filters) {\n      this.alphaMaskIndex++;\n    }\n  }\n  popSpriteMask(maskData) {\n    this.renderer.filter.pop();\n    if (maskData._filters) {\n      maskData._filters[0].maskSprite = null;\n    } else {\n      this.alphaMaskIndex--;\n      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n    }\n  }\n  pushColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  popColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nMaskSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"mask\"\n};\nextensions.add(MaskSystem);\nexport { MaskSystem };","map":{"version":3,"names":["MaskSystem","constructor","renderer","enableScissor","alphaMaskPool","maskDataPool","maskStack","alphaMaskIndex","setMaskStack","scissor","stencil","push","target","maskDataOrTarget","maskData","isMaskData","d","pop","MaskData","pooled","maskObject","maskAbove","length","copyCountersOrReset","_colorMask","autoDetect","detect","_target","type","MASK_TYPES","SPRITE","enabled","SCISSOR","STENCIL","pushSpriteMask","COLOR","pushColorMask","popSpriteMask","popColorMask","reset","maskCurrent","_filters","maskSprite","isSprite","testScissor","alphaMaskFilter","SpriteMaskFilter","renderTextureSystem","renderTexture","resolution","multisample","current","stashFilterArea","filterArea","getBounds","filter","currColorMask","nextColorMask","colorMask","gl","destroy","extension","ExtensionType","RendererSystem","name","extensions","add"],"sources":["/Users/brunoateruel/Personal/Website/bat223.github.io/my-website/node_modules/@pixi/core/src/mask/MaskSystem.ts"],"sourcesContent":["import { MASK_TYPES } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { SpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter';\nimport { MaskData } from './MaskData';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { IMaskTarget } from './MaskData';\n\n/**\n * System plugin to the renderer to manage masks.\n *\n * There are three built-in types of masking:\n * **Scissor Masking**: Scissor masking discards pixels that are outside of a rectangle called the scissor box. It is\n *  the most performant as the scissor test is inexpensive. However, it can only be used when the mask is rectangular.\n * **Stencil Masking**: Stencil masking discards pixels that don't overlap with the pixels rendered into the stencil\n *  buffer. It is the next fastest option as it does not require rendering into a separate framebuffer. However, it does\n *  cause the mask to be rendered **twice** for each masking operation; hence, minimize the rendering cost of your masks.\n * **Sprite Mask Filtering**: Sprite mask filtering discards pixels based on the red channel of the sprite-mask's\n *  texture. (Generally, the masking texture is grayscale). Using advanced techniques, you might be able to embed this\n *  type of masking in a custom shader - and hence, bypassing the masking system fully for performance wins.\n *\n * The best type of masking is auto-detected when you `push` one. To use scissor masking, you must pass in a `Graphics`\n * object with just a rectangle drawn.\n *\n * ## Mask Stacks\n *\n * In the scene graph, masks can be applied recursively, i.e. a mask can be applied during a masking operation. The mask\n * stack stores the currently applied masks in order. Each {@link PIXI.BaseRenderTexture} holds its own mask stack, i.e.\n * when you switch render-textures, the old masks only applied when you switch back to rendering to the old render-target.\n * @memberof PIXI\n */\nexport class MaskSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'mask',\n    };\n\n    /**\n     * Flag to enable scissor masking.\n     * @default true\n     */\n    public enableScissor: boolean;\n\n    /** Pool of used sprite mask filters. */\n    protected readonly alphaMaskPool: Array<SpriteMaskFilter[]>;\n\n    /**\n     * Current index of alpha mask pool.\n     * @default 0\n     * @readonly\n     */\n    protected alphaMaskIndex: number;\n\n    /** Pool of mask data. */\n    private readonly maskDataPool: Array<MaskData>;\n    private maskStack: Array<MaskData>;\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.enableScissor = true;\n        this.alphaMaskPool = [];\n        this.maskDataPool = [];\n\n        this.maskStack = [];\n        this.alphaMaskIndex = 0;\n    }\n\n    /**\n     * Changes the mask stack that is used by this System.\n     * @param maskStack - The mask stack\n     */\n    setMaskStack(maskStack: Array<MaskData>): void\n    {\n        this.maskStack = maskStack;\n        this.renderer.scissor.setMaskStack(maskStack);\n        this.renderer.stencil.setMaskStack(maskStack);\n    }\n\n    /**\n     * Enables the mask and appends it to the current mask stack.\n     *\n     * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.\n     * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n     * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.\n     */\n    push(target: IMaskTarget, maskDataOrTarget: MaskData | IMaskTarget): void\n    {\n        let maskData = maskDataOrTarget as MaskData;\n\n        if (!maskData.isMaskData)\n        {\n            const d = this.maskDataPool.pop() || new MaskData();\n\n            d.pooled = true;\n            d.maskObject = maskDataOrTarget as IMaskTarget;\n            maskData = d;\n        }\n\n        const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n\n        maskData.copyCountersOrReset(maskAbove);\n        maskData._colorMask = maskAbove ? maskAbove._colorMask : 0xf;\n\n        if (maskData.autoDetect)\n        {\n            this.detect(maskData);\n        }\n\n        maskData._target = target;\n\n        if (maskData.type !== MASK_TYPES.SPRITE)\n        {\n            this.maskStack.push(maskData);\n        }\n\n        if (maskData.enabled)\n        {\n            switch (maskData.type)\n            {\n                case MASK_TYPES.SCISSOR:\n                    this.renderer.scissor.push(maskData);\n                    break;\n                case MASK_TYPES.STENCIL:\n                    this.renderer.stencil.push(maskData);\n                    break;\n                case MASK_TYPES.SPRITE:\n                    maskData.copyCountersOrReset(null);\n                    this.pushSpriteMask(maskData);\n                    break;\n                case MASK_TYPES.COLOR:\n                    this.pushColorMask(maskData);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (maskData.type === MASK_TYPES.SPRITE)\n        {\n            this.maskStack.push(maskData);\n        }\n    }\n\n    /**\n     * Removes the last mask from the mask stack and doesn't return it.\n     *\n     * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.\n     * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from\n     */\n    pop(target: IMaskTarget): void\n    {\n        const maskData = this.maskStack.pop();\n\n        if (!maskData || maskData._target !== target)\n        {\n            // TODO: add an assert when we have it\n\n            return;\n        }\n\n        if (maskData.enabled)\n        {\n            switch (maskData.type)\n            {\n                case MASK_TYPES.SCISSOR:\n                    this.renderer.scissor.pop(maskData);\n                    break;\n                case MASK_TYPES.STENCIL:\n                    this.renderer.stencil.pop(maskData.maskObject);\n                    break;\n                case MASK_TYPES.SPRITE:\n                    this.popSpriteMask(maskData);\n                    break;\n                case MASK_TYPES.COLOR:\n                    this.popColorMask(maskData);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        maskData.reset();\n\n        if (maskData.pooled)\n        {\n            this.maskDataPool.push(maskData);\n        }\n\n        if (this.maskStack.length !== 0)\n        {\n            const maskCurrent = this.maskStack[this.maskStack.length - 1];\n\n            if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters)\n            {\n                maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n            }\n        }\n    }\n\n    /**\n     * Sets type of MaskData based on its maskObject.\n     * @param maskData\n     */\n    detect(maskData: MaskData): void\n    {\n        const maskObject = maskData.maskObject;\n\n        if (!maskObject)\n        {\n            maskData.type = MASK_TYPES.COLOR;\n        }\n        else if (maskObject.isSprite)\n        {\n            maskData.type = MASK_TYPES.SPRITE;\n        }\n        else if (this.enableScissor && this.renderer.scissor.testScissor(maskData))\n        {\n            maskData.type = MASK_TYPES.SCISSOR;\n        }\n        else\n        {\n            maskData.type = MASK_TYPES.STENCIL;\n        }\n    }\n\n    /**\n     * Applies the Mask and adds it to the current filter stack.\n     * @param maskData - Sprite to be used as the mask.\n     */\n    pushSpriteMask(maskData: MaskData): void\n    {\n        const { maskObject } = maskData;\n        const target = maskData._target;\n        let alphaMaskFilter = maskData._filters;\n\n        if (!alphaMaskFilter)\n        {\n            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n\n            if (!alphaMaskFilter)\n            {\n                alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n            }\n        }\n\n        const renderer = this.renderer;\n        const renderTextureSystem = renderer.renderTexture;\n\n        let resolution;\n        let multisample;\n\n        if (renderTextureSystem.current)\n        {\n            const renderTexture = renderTextureSystem.current;\n\n            resolution = maskData.resolution || renderTexture.resolution;\n            multisample = maskData.multisample ?? renderTexture.multisample;\n        }\n        else\n        {\n            resolution = maskData.resolution || renderer.resolution;\n            multisample = maskData.multisample ?? renderer.multisample;\n        }\n\n        alphaMaskFilter[0].resolution = resolution;\n        alphaMaskFilter[0].multisample = multisample;\n        alphaMaskFilter[0].maskSprite = maskObject;\n\n        const stashFilterArea = target.filterArea;\n\n        target.filterArea = maskObject.getBounds(true);\n        renderer.filter.push(target, alphaMaskFilter);\n        target.filterArea = stashFilterArea;\n\n        if (!maskData._filters)\n        {\n            this.alphaMaskIndex++;\n        }\n    }\n\n    /**\n     * Removes the last filter from the filter stack and doesn't return it.\n     * @param maskData - Sprite to be used as the mask.\n     */\n    popSpriteMask(maskData: MaskData): void\n    {\n        this.renderer.filter.pop();\n\n        if (maskData._filters)\n        {\n            maskData._filters[0].maskSprite = null;\n        }\n        else\n        {\n            this.alphaMaskIndex--;\n            this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n        }\n    }\n\n    /**\n     * Pushes the color mask.\n     * @param maskData - The mask data\n     */\n    pushColorMask(maskData: MaskData): void\n    {\n        const currColorMask = maskData._colorMask;\n        const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n\n        if (nextColorMask !== currColorMask)\n        {\n            this.renderer.gl.colorMask(\n                (nextColorMask & 0x1) !== 0,\n                (nextColorMask & 0x2) !== 0,\n                (nextColorMask & 0x4) !== 0,\n                (nextColorMask & 0x8) !== 0\n            );\n        }\n    }\n\n    /**\n     * Pops the color mask.\n     * @param maskData - The mask data\n     */\n    popColorMask(maskData: MaskData): void\n    {\n        const currColorMask = maskData._colorMask;\n        const nextColorMask = this.maskStack.length > 0\n            ? this.maskStack[this.maskStack.length - 1]._colorMask : 0xf;\n\n        if (nextColorMask !== currColorMask)\n        {\n            this.renderer.gl.colorMask(\n                (nextColorMask & 0x1) !== 0,\n                (nextColorMask & 0x2) !== 0,\n                (nextColorMask & 0x4) !== 0,\n                (nextColorMask & 0x8) !== 0\n            );\n        }\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(MaskSystem);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}